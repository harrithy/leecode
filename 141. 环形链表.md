# 环形链表

## 题目描述

给你一个链表的头节点 `head`，判断链表中是否有环。

如果链表中存在环，则返回 `true`；否则返回 `false`。

> 环：链表中某个节点的 `next` 指向链表中之前出现过的节点。

## 示例

### 示例 1

```txt
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第 1 个节点（索引从 0 开始）。
```

### 示例 2

```txt
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第 0 个节点。
```

### 示例 3

```txt
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

> `pos` 仅用于说明链表结构，不作为参数传入函数。

## 提示

- 链表中节点的数目范围是 `[0, 10^4]`
- `-10^5 <= Node.val <= 10^5`
- `pos` 为 `-1` 时表示链表无环

## 解题思路

### 方法一：快慢指针（Floyd 判圈，推荐）

核心思路：

- 定义两个指针 `slow` 和 `fast`
- `slow` 每次走 1 步，`fast` 每次走 2 步
- 若链表有环，`fast` 会在环内追上 `slow`，两者必相遇
- 若链表无环，`fast` 会先走到 `null`

这是典型的“龟兔赛跑”模型，时间 `O(n)`，空间 `O(1)`。

### 方法二：哈希表（便于理解）

遍历链表，把访问过的节点引用存入 `Set`：

- 若遇到已存在的节点，说明有环
- 若遍历到 `null`，说明无环

时间 `O(n)`，空间 `O(n)`。

## 代码实现（JavaScript）

### 方法一：快慢指针

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
  if (head === null || head.next === null) return false;

  let slow = head;
  let fast = head;

  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) return true;
  }

  return false;
};

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 方法二：哈希表

```javascript
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
  const visited = new Set();
  let curr = head;

  while (curr !== null) {
    if (visited.has(curr)) return true;
    visited.add(curr);
    curr = curr.next;
  }

  return false;
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

## 常见易错点

- `while` 循环条件写成 `fast.next !== null`，却忘了判断 `fast !== null`。
- 用 `fast === null` 判断无环时遗漏 `fast.next === null` 的情况。
- 把“节点相同”误写成“值相等”，应比较节点引用。

## 总结

- 判环首选快慢指针，空间 `O(1)`。
- 哈希表写法直观，但会额外占用空间。
- 这题是链表题的基础，建议和 `206. 反转链表`、`160. 相交链表` 一起掌握。
