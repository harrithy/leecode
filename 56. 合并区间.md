# 合并区间

## 题目描述

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

## 示例

### 示例 1

```txt
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，将它们合并为 [1,6]。
```

### 示例 2

```txt
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

## 提示

- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 10^4`

## 思路

### 核心想法：排序 + 一次遍历

区间问题的经典套路：**先排序，再处理**。

**为什么要排序？** 排序后，可能重叠的区间一定是相邻的，我们只需要依次比较相邻区间就行啦，不用两两比较所有区间喵~

**如何判断重叠？** 假设当前区间是 `[a, b]`，下一个区间是 `[c, d]`：
- 如果 `c <= b`，说明两个区间重叠，合并成 `[a, max(b, d)]`
- 如果 `c > b`，说明不重叠，当前区间可以加入结果了

## 算法步骤

1. **排序**：按区间的**起点**升序排序
2. **初始化**：把第一个区间放入结果数组
3. **遍历**：从第二个区间开始，依次处理
   - 取出结果数组的**最后一个区间** `last`
   - 如果当前区间的起点 `<= last` 的终点，说明重叠，更新 `last` 的终点为两者终点的最大值
   - 否则不重叠，把当前区间加入结果数组
4. 返回结果数组

## 复杂度分析

- **时间复杂度**：$O(n \log n)$，主要是排序的开销
- **空间复杂度**：$O(\log n)$，排序需要的栈空间（不算结果数组）

## 代码实现（JavaScript）

```javascript
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function (intervals) {
  // 边界情况
  if (intervals.length <= 1) return intervals;

  // 按区间起点排序
  intervals.sort((a, b) => a[0] - b[0]);

  // 结果数组，先放入第一个区间
  const result = [intervals[0]];

  for (let i = 1; i < intervals.length; i++) {
    // 取出结果数组的最后一个区间
    const last = result[result.length - 1];
    // 当前区间
    const curr = intervals[i];

    if (curr[0] <= last[1]) {
      // 有重叠，合并区间（更新终点为两者的最大值）
      last[1] = Math.max(last[1], curr[1]);
    } else {
      // 无重叠，直接加入结果
      result.push(curr);
    }
  }

  return result;
};

// 时间复杂度：O(n log n)
// 空间复杂度：O(log n)
```

## 流程演示

以 `intervals = [[1,3],[2,6],[8,10],[15,18]]` 为例：

**排序后**：`[[1,3],[2,6],[8,10],[15,18]]`（本来就有序）

| i | curr | last | curr[0] <= last[1]? | 操作 | result |
|---|------|------|---------------------|------|--------|
| - | - | - | - | 初始化 | `[[1,3]]` |
| 1 | [2,6] | [1,3] | 2 <= 3 ✓ | 合并，更新终点为 max(3,6)=6 | `[[1,6]]` |
| 2 | [8,10] | [1,6] | 8 <= 6 ✗ | 不重叠，加入 | `[[1,6],[8,10]]` |
| 3 | [15,18] | [8,10] | 15 <= 10 ✗ | 不重叠，加入 | `[[1,6],[8,10],[15,18]]` |

**最终结果**：`[[1,6],[8,10],[15,18]]` 喵~

## 总结

个人认为 intervals.sort((a, b) => a[0] - b[0]); 这个把排序从小到大为关键 排序后只需要比较 b[0]是否小于a[1]
还有一步就是 const last = result[result.length - 1]; 在循环里更新最后一个区间为什么

合并区间是区间问题的入门题，关键点：

1. **排序是关键**：排序后重叠区间必相邻，问题大大简化
2. **合并逻辑**：只需要更新终点，起点不用动（因为排序后当前区间起点一定 >= 上一个区间起点）
3. **贪心思想**：每次都尽可能把能合并的区间合并掉

**相关题目**：
- 57. 插入区间
- 435. 无重叠区间
- 452. 用最少数量的箭引爆气球

这些都是区间问题的变体，套路都差不多呢 QAQ
