# 找到字符串中所有字母异位词

## 题目描述

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

## 示例

### 示例 1

```txt
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

### 示例 2

```txt
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

## 提示

- `1 <= s.length, p.length <= 3 * 10^4`
- `s` 和 `p` 仅包含小写字母

## 思路

### 核心想法：定长滑动窗口 + 词频统计

1. **异位词判断**：两个字符串互为异位词的充分必要条件是它们包含的**字符种类和每个字符出现的次数**完全相同。
2. **滑动窗口**：因为 `p` 的异位词长度一定等于 `p.length`，所以我们可以在 `s` 上维护一个长度为 `p.length` 的**固定窗口**。
3. **词频统计**：由于字符仅包含小写字母，我们可以使用长度为 26 的数组来统计窗口内字符出现的频率。
4. **窗口滑动**：
    - 初始时，统计 `p` 的词频以及 `s` 前 `p.length` 个字符的词频。
    - 比较两个词频数组是否相等，若相等则记录索引 `0`。
    - 向右滑动窗口：移除窗口最左侧字符（频次减 1），加入窗口右侧新字符（频次加 1）。
    - 每滑动一步，比较一次词频数组。

## 复杂度分析

- **时间复杂度**：$O(n + m + \Sigma)$，其中 $n$ 是 $s$ 的长度，$m$ 是 $p$ 的长度，$\Sigma$ 是字符集大小（此处为 26）。我们需要遍历一次 $p$ 和一次 $s$，且每次移动窗口需要 $O(\Sigma)$ 的时间比较数组。
- **空间复杂度**：$O(\Sigma)$，需要两个长度为 26 的数组来存储词频。

## 代码实现（JavaScript）

```javascript
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s, p) {
  const sLen = s.length,
    pLen = p.length;
  if (sLen < pLen) return [];

  const ans = [];
  const sCount = new Array(26).fill(0);
  const pCount = new Array(26).fill(0);

  // 统计 p 的词频和 s 最初窗口的词频
  for (let i = 0; i < pLen; i++) {
    sCount[s.charCodeAt(i) - "a".charCodeAt(0)]++;
    pCount[p.charCodeAt(i) - "a".charCodeAt(0)]++;
  }

  // 比较初始窗口
  if (sCount.toString() === pCount.toString()) {
    ans.push(0);
  }

  // 开始滑动窗口
  for (let i = 0; i < sLen - pLen; i++) {
    // 移除左侧字符
    sCount[s.charCodeAt(i) - "a".charCodeAt(0)]--;
    // 加入右侧字符
    sCount[s.charCodeAt(i + pLen) - "a".charCodeAt(0)]++;

    // 比较当前窗口词频
    if (sCount.toString() === pCount.toString()) {
      ans.push(i + 1);
    }
  }

  return ans;
};
```

``` javascript
// 我的做法 但是会超时
var findAnagrams = function(s, p) {
    // 记录对应的起始索引
    // let map = new Map();
    // 比较长度大小
    let p1 = p.split('').sort().join();
    // map.set(p1,[]);
    let arr = []
    for(let i = 0;i<(s.length - p.length + 1);i++) {
        let s1 = s.slice(i,(i + p.length)).split('').sort().join();
        if (p1 == s1) {
            arr.push(i)
        }
    }
    return arr;
};
```

## 总结

1. **定长窗口**：本题窗口大小固定为 `p.length`，简化了边界处理。
2. **数组对比**：在 JavaScript 中，简单对比两个小数组可以通过 `toString()` 转换为字符串比较，也可以手动循环比较。
3. **优化技巧**：如果字符集很大，可以使用哈希表（Map）并维护一个 `differ` 变量记录两个频率统计的不同字符数，从而将对比复杂度从 $O(\Sigma)$ 优化到 $O(1)$。
