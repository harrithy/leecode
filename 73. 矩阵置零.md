# 矩阵置零

## 题目描述

给定一个 `m x n` 的矩阵，如果一个元素为 **0**，则将其所在行和列的所有元素都设为 **0**。请使用**原地**算法。

## 示例

### 示例 1

```txt
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

### 示例 2

```txt
输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

## 提示

- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-2^31 <= matrix[i][j] <= 2^31 - 1`

**进阶**：

- 一个直观的解决方案是使用 `O(mn)` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(m + n)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

## 思路

### 为什么不能直接置零？

如果遇到 0 就立刻把整行整列置零，那后面遍历到这些新的 0 时，又会把更多的行列置零，最后整个矩阵都变成 0 了喵 QAQ

所以要**先标记，后置零**。

### 方法一：额外数组标记（O(m+n) 空间）

用两个数组分别记录哪些行、哪些列需要置零。

### 方法二：用第一行第一列作为标记（O(1) 空间）

这是最优解！核心思想：**用矩阵的第一行和第一列来充当标记数组**。

- `matrix[i][0] = 0` 表示第 i 行需要置零
- `matrix[0][j] = 0` 表示第 j 列需要置零

但是！第一行和第一列本身也可能需要置零，所以要用两个额外变量记录。

## 复杂度分析

| 方法         | 时间复杂度 | 空间复杂度 |
| ------------ | ---------- | ---------- |
| 额外数组     | $O(mn)$    | $O(m+n)$   |
| 第一行列标记 | $O(mn)$    | $O(1)$     |

## 代码实现（JavaScript）

### 方法一：额外数组标记

```javascript
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {
  const m = matrix.length;
  const n = matrix[0].length;

  // 记录哪些行、哪些列需要置零
  const rows = new Set();
  const cols = new Set();

  // 第一遍：找出所有 0 的位置
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (matrix[i][j] === 0) {
        rows.add(i);
        cols.add(j);
      }
    }
  }

  // 第二遍：置零
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (rows.has(i) || cols.has(j)) {
        matrix[i][j] = 0;
      }
    }
  }
};

// 时间复杂度：O(mn)
// 空间复杂度：O(m+n)
```

### 方法二：用第一行第一列作为标记（最优解）

```javascript
/**
 * @param {number[][]} matrix
 * @return {void}
 */
var setZeroes = function (matrix) {
  const m = matrix.length;
  const n = matrix[0].length;

  // 记录第一行和第一列是否本身需要置零
  let firstRowZero = false;
  let firstColZero = false;

  // 检查第一列是否有 0
  for (let i = 0; i < m; i++) {
    if (matrix[i][0] === 0) {
      firstColZero = true;
      break;
    }
  }

  // 检查第一行是否有 0
  for (let j = 0; j < n; j++) {
    if (matrix[0][j] === 0) {
      firstRowZero = true;
      break;
    }
  }

  // 用第一行第一列作为标记，遍历剩余部分
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      if (matrix[i][j] === 0) {
        matrix[i][0] = 0; // 标记这一行需要置零
        matrix[0][j] = 0; // 标记这一列需要置零
      }
    }
  }

  // 根据标记，置零（注意：要先处理非第一行第一列的部分）
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      if (matrix[i][0] === 0 || matrix[0][j] === 0) {
        matrix[i][j] = 0;
      }
    }
  }

  // 最后处理第一行
  if (firstRowZero) {
    for (let j = 0; j < n; j++) {
      matrix[0][j] = 0;
    }
  }

  // 最后处理第一列
  if (firstColZero) {
    for (let i = 0; i < m; i++) {
      matrix[i][0] = 0;
    }
  }
};

// 时间复杂度：O(mn)
// 空间复杂度：O(1)
```

## 流程演示

以 `matrix = [[1,1,1],[1,0,1],[1,1,1]]` 为例（方法二）：

**初始矩阵**：

```
[1, 1, 1]
[1, 0, 1]
[1, 1, 1]
```

**第一步**：检查第一行第一列

- `firstRowZero = false`（第一行没有 0）
- `firstColZero = false`（第一列没有 0）

**第二步**：遍历并标记

- 发现 `matrix[1][1] = 0`
- 标记：`matrix[1][0] = 0`，`matrix[0][1] = 0`

```
[1, 0, 1]    ← matrix[0][1] 被标记为 0
[0, 0, 1]    ← matrix[1][0] 被标记为 0
[1, 1, 1]
```

**第三步**：根据标记置零

- 第 1 行（`matrix[1][0]=0`）→ 整行置零
- 第 1 列（`matrix[0][1]=0`）→ 整列置零

```
[1, 0, 1]
[0, 0, 0]
[1, 0, 1]
```

**最终结果**：`[[1,0,1],[0,0,0],[1,0,1]]` ✓

## 总结

矩阵置零的关键点：

1. **先标记后置零**：不能边遍历边置零，否则会"污染"后面的判断
2. **原地标记技巧**：用第一行第一列作为标记数组，省掉额外空间
3. **处理顺序很重要**：
   - 先检查第一行第一列本身是否有 0
   - 再用它们做标记
   - 先置零非第一行列的部分
   - 最后处理第一行第一列

这道题和 41 题（缺失的第一个正数）思路类似，都是**把数组/矩阵本身当作额外存储空间**喵 QAQ

## 知识点

### Set 是什么？

`Set` 是一个**只存值、不存键值对**的集合，而且**自动去重**。适合用来记录"有没有"这类场景。

### Set 常用方法

| 方法            | 作用         | 示例                    |
| --------------- | ------------ | ----------------------- |
| `new Set()`     | 创建空集合   | `const set = new Set()` |
| `add(value)`    | 添加元素     | `set.add(1)`            |
| `has(value)`    | 判断是否存在 | `set.has(1)` → `true`   |
| `delete(value)` | 删除元素     | `set.delete(1)`         |
| `clear()`       | 清空集合     | `set.clear()`           |
| `size`          | 获取元素个数 | `set.size` → `0`        |

```javascript
const set = new Set();
set.add(1);
set.add(2);
set.add(1); // 重复添加，自动忽略
console.log(set); // Set {1, 2}
set.has(1); // true
set.has(3); // false
```

### Set vs Map 对比

| 特性     | Set              | Map                             |
| -------- | ---------------- | ------------------------------- |
| 存储内容 | 只存值           | 存键值对                        |
| 用途     | 记录"有没有"     | 记录"是什么"                    |
| 添加     | `set.add(value)` | `map.set(key, value)`           |
| 查询     | `set.has(value)` | `map.has(key)` / `map.get(key)` |
| 去重     | 值自动去重       | 键自动去重                      |

### 什么时候用哪个？

| 场景                   | 用什么 | 原因                   |
| ---------------------- | ------ | ---------------------- |
| 记录哪些行/列需要处理  | `Set`  | 只需要知道"有没有"     |
| 统计字符出现次数       | `Map`  | 需要记录"出现了几次"   |
| 数组去重               | `Set`  | `[...new Set(arr)]`    |
| 两数之和（存值和索引） | `Map`  | 需要记录"值对应的索引" |
| 判断元素是否存在       | `Set`  | 只关心存在性           |

```javascript
// Set 场景：数组去重
const arr = [1, 2, 2, 3, 3, 3];
const unique = [...new Set(arr)]; // [1, 2, 3]

// Map 场景：统计词频
const map = new Map();
for (const char of "aabbc") {
  map.set(char, (map.get(char) || 0) + 1);
}
// Map {'a' => 2, 'b' => 2, 'c' => 1}
```
