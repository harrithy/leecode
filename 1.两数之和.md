# 两数之和

## 题目描述

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

## 示例

```txt
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

```txt
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

```txt
输入：nums = [3,3], target = 6
输出：[0,1]
```

## 提示

- 2 <= nums.length <= 104
- -109 <= nums[i] <= 109
- -109 <= target <= 109
- 只会存在一个有效答案

## 解决方案

### 方法一：暴力枚举

``` JavaScript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // 每一个数都与后面的数相加
    for(let i = 0; i < nums.length; i++) {
        for (let j= 1; j < nums.length; j++) {
            // 注意：i < j 是为了避免重复出现
            // 例如：[3,2,4] target = 6，[0,1] 和 [1,0] 是重复的
            if (nums[i] + nums[j] == target && i < j){
                return [i,j]
            }
        }
    }
};
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
```

``` txt
//Add time and space complexity analysis for the hash table method
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 方法二：哈希表

``` javaScript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // 用哈希表存储已经遍历过的数
    let map = new Map();
    for(let i = 0; i < nums.length; i++) {
        // 如果哈希表中存在 target - nums[i]，则返回结果
        if(map.has(target - nums[i])) {
            return [map.get(target - nums[i]), i];
        }
        // 否则，将 nums[i] 加入哈希表
        map.set(nums[i], i);
    }
};
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

## 总结

主要对哈希表的应用，通过一次遍历数组，将每个元素和它的索引存储在哈希表中。在遍历的过程中，检查哈希表中是否存在目标值与当前元素的差值。如果存在，则返回当前元素的索引和哈希表中差值的索引。
map的方法有：

- map.has(key)：判断哈希表中是否存在 key
- map.get(key)：获取哈希表中 key 对应的值
- map.set(key, value)：将 key 和 value 加入哈希表
- map.set(key, value)：如果 key 已存在，会覆盖旧值（可用于更新某个 key 对应的值）
- map.delete(key)：删除指定 key 的键值对，返回布尔值
- map.clear()：清空整个哈希表
