# 最大子数组和

## 题目描述

给你一个整数数组 `nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

## 示例

### 示例 1

```txt
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

### 示例 2

```txt
输入：nums = [1]
输出：1
```
         
### 示例 3

```txt
输入：nums = [5,4,-1,7,8]
输出：23
```

## 提示

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

## 思路

### 核心想法：动态规划（Kadane 算法）

这道题是动态规划的入门经典题，也被称为 **Kadane 算法**。

**关键洞察**：对于每个位置 `i`，我们需要做一个决策——是把 `nums[i]` 加入前面的子数组，还是从 `nums[i]` 重新开始一个新的子数组？

**状态定义**：设 `dp[i]` 表示以 `nums[i]` **结尾**的最大子数组和。

**状态转移**：
- 如果 `dp[i-1] > 0`，说明前面的子数组和是正贡献，加上它会让结果更大：`dp[i] = dp[i-1] + nums[i]`
- 如果 `dp[i-1] <= 0`，说明前面的子数组和是负贡献或零贡献，不如从当前位置重新开始：`dp[i] = nums[i]`

简化为：`dp[i] = Math.max(dp[i-1] + nums[i], nums[i])`

**空间优化**：由于 `dp[i]` 只依赖于 `dp[i-1]`，我们可以用一个变量 `pre` 代替整个 dp 数组，将空间复杂度从 $O(n)$ 优化到 $O(1)$。

## 算法步骤

1. **初始化**：`pre = 0`（前一个位置的最大子数组和），`maxSum = nums[0]`（全局最大值）
2. **遍历数组**：
   - 计算以当前位置结尾的最大子数组和：`pre = Math.max(pre + nums[i], nums[i])`
   - 更新全局最大值：`maxSum = Math.max(maxSum, pre)`
3. 返回 `maxSum`

## 复杂度分析

- **时间复杂度**：$O(n)$，只需遍历数组一次0
- **空间复杂度**：$O(1)$，只使用常数级额外空间

## 代码实现（JavaScript）

### 方法一：动态规划（空间优化版）

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  // pre 表示以前一个位置结尾的最大子数组和
  let pre = 0;
  // maxSum 记录全局最大值
  let maxSum = nums[0];

  for (let i = 0; i < nums.length; i++) {
    // 决策：是加入前面的子数组，还是从当前位置重新开始
    // 如果 pre + nums[i] > nums[i]，说明 pre > 0，前面有正贡献
    pre = Math.max(pre + nums[i], nums[i]);
    // 更新全局最大值
    maxSum = Math.max(maxSum, pre);
  }

  return maxSum;
};

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 方法二：动态规划（完整 dp 数组版，便于理解）

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  const n = nums.length;
  // dp[i] 表示以 nums[i] 结尾的最大子数组和
  const dp = [];

  // 初始化：以第一个元素结尾的最大子数组和就是它本身
  dp[0] = nums[0];
  let maxSum = dp[0];

  for (let i = 1; i < n; i++) {
    // 状态转移：要么加入前面的子数组，要么从当前位置重新开始
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
    // 更新全局最大值
    maxSum = Math.max(maxSum, dp[i]);
  }

  return maxSum;
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 方法三：分治法

分治法的思想是把数组从中间分成左右两部分，最大子数组只可能出现在三个地方：
1. 完全在左半部分
2. 完全在右半部分
3. **跨越中点**，一部分在左边，一部分在右边

前两种情况可以递归求解，第三种情况需要从中点向两边扩展找最大值。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  return divideAndConquer(nums, 0, nums.length - 1);
};

/**
 * 分治递归函数
 */
function divideAndConquer(nums, left, right) {
  // 递归终止条件：只有一个元素
  if (left === right) {
    return nums[left];
  }

  const mid = Math.floor((left + right) / 2);

  // 递归求解左半部分的最大子数组和
  const leftMax = divideAndConquer(nums, left, mid);
  // 递归求解右半部分的最大子数组和
  const rightMax = divideAndConquer(nums, mid + 1, right);
  // 求解跨越中点的最大子数组和
  const crossMax = maxCrossingSum(nums, left, mid, right);

  // 返回三者中的最大值
  return Math.max(leftMax, rightMax, crossMax);
}

/**
 * 计算跨越中点的最大子数组和
 */
function maxCrossingSum(nums, left, mid, right) {
  // 从中点向左扩展，找到左边的最大和
  let leftSum = -Infinity;
  let sum = 0;
  for (let i = mid; i >= left; i--) {
    sum += nums[i];
    leftSum = Math.max(leftSum, sum);
  }

  // 从中点向右扩展，找到右边的最大和
  let rightSum = -Infinity;
  sum = 0;
  for (let i = mid + 1; i <= right; i++) {
    sum += nums[i];
    rightSum = Math.max(rightSum, sum);
  }

  // 跨越中点的最大和 = 左边最大 + 右边最大
  return leftSum + rightSum;
}

// 时间复杂度：O(n log n)，每层递归 O(n)，共 log n 层
// 空间复杂度：O(log n)，递归栈深度
```

## 总结

最大子数组和是动态规划的经典入门题，关键点：

最主要的是计算当前位置的最大值，用一个dp[]数组来记录每一个位置当前的最大值，
比如dp[0] = nums[0], nums数组的第一个位置的和是 0 所以最大值是0
第二步是用当前的最大值与 nums[1] 相加 再与nums[1]本身比较 就是 Math.max(dp[0] + nums[1], nums[1])
过程就是 nums[0] + nums[1] = dp[0] + nums[1] 求出来前两位之间的和 如果＜nums[1] 说明前面的相加都是负反馈，可以弃掉 重新在nums[1]开始，即 dp[1] = nums[1]
否则 dp[1] = dp[0] + nums[1]
同时同步最大值

1. **状态定义**：`dp[i]` 表示以 `nums[i]` **结尾**的最大子数组和。注意是"结尾"而不是"前 i 个元素中"，这个定义方式保证了子数组的连续性。
2. **决策思想**：每个位置只有两个选择——加入前面的子数组，或者另起炉灶。选择的依据是前面的累计和是正贡献还是负贡献。
3. **空间优化**：由于状态只依赖前一个位置，可以用单变量代替数组。
4. **与前缀和的区别**：第 560 题（和为 K 的子数组）用前缀和 + 哈希表，因为要找特定和；本题用 DP，因为要找最大和。

**进阶思考**：如果要求返回最大子数组本身（而不只是和），可以在更新 `maxSum` 时同时记录子数组的起始和结束位置喵~
