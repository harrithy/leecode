# 最小覆盖子串

## 题目描述

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

## 示例

### 示例 1

```txt
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

### 示例 2

```txt
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

### 示例 3

```txt
输入：s = "a", t = "aa"
输出：""
解释：t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。
```

## 提示

- `1 <= s.length, t.length <= 10^5`
- `s` 和 `t` 由英文字母组成

## 思路

### 核心想法：滑动窗口 + 词频统计

这道题是滑动窗口的经典难题。和 438 题（找到字符串中所有字母异位词）类似，都需要用词频统计来判断窗口是否满足条件。但不同的是，438 题的窗口大小固定，而本题的窗口大小是**可变的**——我们需要找到**最小的**满足条件的窗口。

**整体策略：先扩大窗口找到可行解，再收缩窗口优化解。**

1. **词频统计**：用哈希表 `need` 记录 `t` 中每个字符需要的数量，用哈希表 `window` 记录当前窗口中各字符的数量。
2. **有效字符计数**：用变量 `valid` 记录窗口中已经满足 `need` 条件的字符**种类数**。当 `valid === need.size` 时，说明窗口已经完全覆盖了 `t`。
3. **右指针扩张**：不断移动右指针扩大窗口，将字符加入窗口统计。
4. **左指针收缩**：当窗口满足条件时，尝试移动左指针缩小窗口，在满足条件的前提下寻找更短的子串。
5. **记录最优解**：每次窗口满足条件时，更新最小覆盖子串的起始位置和长度。

## 算法步骤

1. **初始化**：
   - `need`：统计 `t` 中每个字符的频次
   - `window`：记录当前窗口中各字符的频次
   - `valid`：已满足条件的字符种类数
   - `start`、`len`：记录最小覆盖子串的起始位置和长度
2. **右指针遍历** `s`：
   - 将 `s[right]` 加入窗口，如果它是 `t` 中需要的字符，更新 `window` 计数
   - 如果某个字符在窗口中的数量达到了 `need` 中的要求，`valid++`
3. **左指针收缩**（当 `valid === need.size` 时）：
   - 更新最小子串的记录
   - 将 `s[left]` 移出窗口，如果它是 `t` 中需要的字符，更新 `window` 计数
   - 如果某个字符在窗口中的数量不再满足 `need`，`valid--`
   - `left++`
4. 返回结果

## 复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 是 `s` 的长度，$m$ 是 `t` 的长度。左右指针各最多遍历 `s` 一次。
- **空间复杂度**：$O(|\Sigma|)$，其中 $|\Sigma|$ 是字符集大小。哈希表最多存储字符集大小的键值对。

## 代码实现（JavaScript）

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
  // need 记录 t 中每个字符需要的数量
  const need = new Map();
  // window 记录当前窗口中各字符的数量
  const window = new Map();

  // 统计 t 的词频
  for (const c of t) {
    need.set(c, (need.get(c) || 0) + 1);
  }

  let left = 0;
  let right = 0;
  // valid 表示窗口中满足 need 条件的字符种类数
  let valid = 0;
  // 记录最小覆盖子串的起始索引和长度
  let start = 0;
  let len = Infinity;

  while (right < s.length) {
    // c 是将要移入窗口的字符
    const c = s[right];
    // 扩大窗口
    right++;

    // 如果当前字符是 t 中需要的，更新窗口数据
    if (need.has(c)) {
      window.set(c, (window.get(c) || 0) + 1);
      // 当窗口中该字符的数量恰好满足需求时，valid 加 1
      if (window.get(c) === need.get(c)) {
        valid++;
      }
    }

    // 当所有字符都满足条件时，开始收缩左边界
    while (valid === need.size) {
      // 更新最小覆盖子串
      if (right - left < len) {
        start = left;
        len = right - left;
      }

      // d 是将要移出窗口的字符
      const d = s[left];
      // 缩小窗口
      left++;

      // 如果移出的字符是 t 中需要的，更新窗口数据
      if (need.has(d)) {
        // 如果移出后该字符数量将不满足需求，valid 减 1
        if (window.get(d) === need.get(d)) {
          valid--;
        }
        window.set(d, window.get(d) - 1);
      }
    }
  }

  // 如果 len 没有被更新过，说明没有找到满足条件的子串
  return len === Infinity ? "" : s.substring(start, start + len);
};

// 时间复杂度：O(n + m)，n 是 s 的长度，m 是 t 的长度
// 空间复杂度：O(|Σ|)，Σ 是字符集大小
```

## 总结

最小覆盖子串是滑动窗口的经典难题，也是滑动窗口的**模板题**，关键点：

1. **滑动窗口框架**：右指针扩张寻找可行解，左指针收缩优化解。这个"先扩后缩"的模式适用于大量子串/子数组问题。
2. **valid 计数技巧**：不是逐个字符比较两个哈希表，而是用 `valid` 变量记录满足条件的字符种类数，当 `valid === need.size` 时即满足条件，将判断从 $O(|\Sigma|)$ 优化到 $O(1)$。
3. **注意收缩时机**：`valid` 的增减顺序很重要——扩张时先更新 `window` 再判断 `valid`，收缩时先判断 `valid` 再更新 `window`。
4. **与其他滑动窗口题的对比**：
   - 第 3 题（无重复字符的最长子串）：窗口不满足条件时收缩，求最大窗口
   - 第 438 题（字母异位词）：固定窗口大小，词频完全匹配
   - 第 76 题（本题）：窗口满足条件时收缩，求最小窗口
