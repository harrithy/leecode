# 除自身以外数组的乘积

## 题目描述

给你一个整数数组 `nums`，返回数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

题目数据**保证**数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 32 位整数范围内。

请**不要使用除法**，且在 `O(n)` 时间复杂度内完成此题。

## 示例

### 示例 1

```txt
输入：nums = [1,2,3,4]
输出：[24,12,8,6]
解释：
answer[0] = 2 * 3 * 4 = 24
answer[1] = 1 * 3 * 4 = 12
answer[2] = 1 * 2 * 4 = 8
answer[3] = 1 * 2 * 3 = 6
```

### 示例 2

```txt
输入：nums = [-1,1,0,-3,3]
输出：[0,0,9,0,0]
```

## 提示

- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- 保证数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 32 位整数范围内

**进阶**：你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（出于对空间复杂度分析的目的，输出数组不被视为额外空间）

## 思路

### 核心想法：前缀积 × 后缀积

不能用除法，那怎么算"除了自己以外的乘积"呢？

**关键洞察**：`answer[i] = 左边所有数的乘积 × 右边所有数的乘积`

```txt
nums = [1, 2, 3, 4]

对于 nums[2] = 3：
- 左边乘积：1 × 2 = 2
- 右边乘积：4
- answer[2] = 2 × 4 = 8
```

所以我们需要：
- **前缀积**：`prefix[i]` = `nums[0] × nums[1] × ... × nums[i-1]`
- **后缀积**：`suffix[i]` = `nums[i+1] × nums[i+2] × ... × nums[n-1]`

最终：`answer[i] = prefix[i] × suffix[i]`

## 算法步骤

### 方法一：两个数组（易理解）

1. 计算前缀积数组 `prefix`
2. 计算后缀积数组 `suffix`
3. `answer[i] = prefix[i] × suffix[i]`

### 方法二：空间优化（进阶）

1. 先用 `answer` 数组存前缀积
2. 再从右往左遍历，用一个变量 `suffix` 累积后缀积，边遍历边乘到 `answer` 上

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| 两个数组 | $O(n)$ | $O(n)$ |
| 空间优化 | $O(n)$ | $O(1)$（不算输出数组） |

## 代码实现（JavaScript）

### 方法一：前缀积 + 后缀积（两个数组）

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {
  const n = nums.length;

  // prefix[i] 表示 nums[0..i-1] 的乘积
  const prefix = new Array(n);
  prefix[0] = 1; // 第一个元素左边没有数，乘积为 1
  for (let i = 1; i < n; i++) {
    prefix[i] = prefix[i - 1] * nums[i - 1];
  }

  // suffix[i] 表示 nums[i+1..n-1] 的乘积
  const suffix = new Array(n);
  suffix[n - 1] = 1; // 最后一个元素右边没有数，乘积为 1
  for (let i = n - 2; i >= 0; i--) {
    suffix[i] = suffix[i + 1] * nums[i + 1];
  }

  // answer[i] = 左边乘积 × 右边乘积
  const answer = new Array(n);
  for (let i = 0; i < n; i++) {
    answer[i] = prefix[i] * suffix[i];
  }

  return answer;
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 方法二：空间优化版（推荐）

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {
  const n = nums.length;
  const answer = new Array(n);

  // 第一遍：计算前缀积，存入 answer
  answer[0] = 1;
  for (let i = 1; i < n; i++) {
    answer[i] = answer[i - 1] * nums[i - 1];
  }

  // 第二遍：从右往左，边计算后缀积边乘到 answer 上
  let suffix = 1;
  for (let i = n - 1; i >= 0; i--) {
    answer[i] = answer[i] * suffix; // 前缀积 × 后缀积
    suffix = suffix * nums[i]; // 更新后缀积
  }

  return answer;
};

// 时间复杂度：O(n)
// 空间复杂度：O(1)（不算输出数组）
```

## 流程演示

以 `nums = [1, 2, 3, 4]` 为例：

**第一遍：计算前缀积**

| i | nums[i] | answer[i] = answer[i-1] × nums[i-1] |
|---|---------|-------------------------------------|
| 0 | 1 | 1（初始值） |
| 1 | 2 | 1 × 1 = 1 |
| 2 | 3 | 1 × 2 = 2 |
| 3 | 4 | 2 × 3 = 6 |

此时 `answer = [1, 1, 2, 6]`（存的是前缀积）

**第二遍：乘上后缀积**

| i | nums[i] | suffix（乘之前） | answer[i] = answer[i] × suffix | suffix 更新 |
|---|---------|-----------------|-------------------------------|-------------|
| 3 | 4 | 1 | 6 × 1 = 6 | 1 × 4 = 4 |
| 2 | 3 | 4 | 2 × 4 = 8 | 4 × 3 = 12 |
| 1 | 2 | 12 | 1 × 12 = 12 | 12 × 2 = 24 |
| 0 | 1 | 24 | 1 × 24 = 24 | 24 × 1 = 24 |

**最终结果**：`answer = [24, 12, 8, 6]` 喵~

## 总结

这道题的关键点：

1. **不能用除法**：所以不能先算总乘积再除，要用前缀积 × 后缀积
2. **前缀积思想**：类似前缀和，`prefix[i]` 存的是 `i` 左边所有数的乘积
3. **空间优化技巧**：先用 `answer` 存前缀积，再从右往左用一个变量累积后缀积

**相关题目**：
- 前缀和系列（560. 和为 K 的子数组）
- 这道题是"前缀积"的应用呢 QAQ
