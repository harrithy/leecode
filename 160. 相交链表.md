# 相交链表

## 题目描述

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。

如果两个链表不存在相交节点，返回 `null`。

题目数据保证整个链式结构中不存在环。

注意：

- 函数返回结果后，链表必须保持原始结构。

## 示例

### 示例 1

```txt
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
```

### 示例 2

```txt
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
```

### 示例 3

```txt
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
```

## 提示

- 两个链表节点数目分别为 `m` 和 `n`
- `1 <= m, n <= 3 * 10^4`
- `1 <= Node.val <= 10^5`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- `intersectVal` 为 `0` 时表示不相交

## 解题思路

### 方法一：双指针（推荐，空间 O(1)）

核心思想：

- 指针 `pA` 从 `headA` 出发，走到末尾后跳到 `headB`
- 指针 `pB` 从 `headB` 出发，走到末尾后跳到 `headA`

这样两条路径长度都变成了 `m + n`：

- `pA` 走的是 `A + B`
- `pB` 走的是 `B + A`

如果有相交点，它们会在相交起点相遇；
如果没有相交点，它们最终会同时走到 `null`，也会相等。

### 为什么一定会相遇？

设：

- 链表 A 独有长度为 `a`
- 链表 B 独有长度为 `b`
- 公共尾部长度为 `c`

则：

- `lenA = a + c`
- `lenB = b + c`

两指针各自走完两条链后，都会走 `a + b + c` 的有效节点长度（总路程一致），所以要么在公共起点第一次相遇，要么同为 `null`。

## 代码实现（JavaScript）

### 方法一：双指针

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
  // 任一链表为空，不可能相交
  if (headA === null || headB === null) return null;
  // 让pA指向headA的表头地址
  let pA = headA;
  // 让pB指向headB的表头地址
  let pB = headB;

  // 相遇条件：同一节点（包括同为 null）
  while (pA !== pB) {
    // 走到末尾后切到另一条链表头
    pA = pA === null ? headB : pA.next;
    pB = pB === null ? headA : pB.next;
  }

  return pA;
};

// 时间复杂度：O(m + n)
// 空间复杂度：O(1)
```

### 方法二：哈希表（便于理解）

先遍历链表 A，把所有节点引用放进 `Set`；
再遍历链表 B，第一次遇到在 `Set` 中出现过的节点就是相交点。

```javascript
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
  const visited = new Set();

  let curA = headA;
  while (curA !== null) {
    visited.add(curA);
    curA = curA.next;
  }

  let curB = headB;
  while (curB !== null) {
    if (visited.has(curB)) {
      return curB;
    }
    curB = curB.next;
  }

  return null;
};

// 时间复杂度：O(m + n)
// 空间复杂度：O(m)
```

## 总结

- 本题关键在于“节点相交”判断的是**节点引用相同**，不是值相同。
- 最优解是双指针：不需要先算长度，也不需要额外哈希空间。
- 双指针通过“互换起点”消除长度差，是链表题中非常经典的技巧。

## 链表相关知识补充

### 1）链表基础概念

- **链表节点**通常包含两部分：`val`（值）和 `next`（指向下一个节点）。
- 单链表只能从前往后访问，不支持像数组那样 `O(1)` 下标访问。
- 链表中常见的“头节点”是入口，遍历通常从 `head` 开始直到 `null`。

### 2）时间复杂度对比（和数组）

- 链表按位置访问：`O(n)`（数组是 `O(1)`）
- 已知节点后插入/删除：`O(1)`（数组通常需要搬移元素）
- 查找某个值：`O(n)`（两者都可能是线性）

### 3）链表相交的判定本质

- 判断相交看的是**是否为同一个节点对象（引用相同）**，不是 `val` 是否相等。
- 一旦两链表相交，后续部分一定完全重合（因为每个节点只有一个 `next`）。

### 4）链表题常用技巧

- **哑节点（dummy）**：统一处理头节点变更问题（如删除、合并）。
- **快慢指针**：用于找中点、判断环、找环入口。
- **双指针换头**：用于消除路径差（本题经典解法）。
- **断链与重连**：反转链表、分组反转、重排链表的核心操作。

### 5）常见易错点

- 循环条件写错导致空指针：访问 `node.next` 前要先判断 `node` 是否为 `null`。
- 把“值相等”误当成“节点相同”。
- 修改链表指针顺序不当，导致后续节点丢失（建议先保存 `next`）。

### 6）JavaScript 链表节点写法（LeetCode 常见）

```javascript
function ListNode(val, next = null) {
  this.val = val;
  this.next = next;
}
```

这类题建议优先掌握这几道基础题型：反转链表、删除倒数第 N 个节点、环形链表、合并两个有序链表、相交链表。
