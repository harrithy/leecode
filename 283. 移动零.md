# 283. 移动零

## 题目描述

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

## 示例

**示例 1:**

```text
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```text
输入: nums = [0]
输出: [0]
```

## 提示

- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

## 解决方案

### 方法一：双指针（交换法）

我们可以使用两个指针 `left` 和 `right` 来维护数组的状态。

- `left` 指针：指向当前已经处理好的序列的尾部（即非零元素的下一个位置）。
- `right` 指针：用于遍历数组，寻找非零元素。

**算法流程：**

1. 初始化 `left = 0`，`right = 0`。
2. `right` 指针向右移动遍历数组：
    - 如果 `nums[right]` 不为 0，则将 `nums[right]` 与 `nums[left]` 交换，并将 `left` 向右移动一位。
    - 如果 `nums[right]` 为 0，则不做任何操作，`right` 继续向右移动。
3. 遍历结束后，所有的非零元素都被移动到了数组的左侧，且保持了相对顺序，所有的 0 都被移动到了数组的右侧。

**为什么是交换？**
因为 `left` 指针左侧永远是非零元素。当 `right` 遇到非零元素时，我们需要把它放到 `left` 的位置。如果 `left` 和 `right` 指向同一个位置（比如数组开头就是非零数），交换无影响；如果 `left` 指向的是 0（之前跳过的），交换后 0 就被移到了后面，非零数移到了前面。

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let left = 0;
    
    for (let right = 0; right < nums.length; right++) {
        // 如果当前元素不为 0，则将其交换到左边
        if (nums[right] !== 0) {
            // 优化：只有当 left 和 right 不指向同一个位置时才需要交换
            // 避免 [1, 2, ...] 这种情况下自己和自己交换
            if (right > left) {
                [nums[left], nums[right]] = [nums[right], nums[left]];
            }
            left++;
        }
    }
};

// 时间复杂度：O(n)，其中 n 为数组的长度。每个元素至多被遍历一次。
// 空间复杂度：O(1)，只需要常数空间存放指针。
```

### 方法二：两次遍历（覆盖 + 补零）

这是一种更直观但操作次数可能稍多的方法。

1. 第一次遍历：将所有**非零**元素按顺序移动到数组头部。
2. 第二次遍历：将剩余的位置全部填充为 0。

```javascript
/**
 * @param {number[]} nums
 * @return {void}
 */
var moveZeroes = function(nums) {
    let j = 0; // j 记录非零元素应该放置的位置
    
    // 第一次遍历：把非零元素往前挪
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            nums[j] = nums[i];
            j++;
        }
    }
    
    // 第二次遍历：把剩下的位置补 0
    for (let i = j; i < nums.length; i++) {
        nums[i] = 0;
    }
};
// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

## 总结

**双指针（交换法）** 是最优解，它能在一次遍历中完成任务，并且对于非零元素极多的情况（例如 `[1, 2, 3, 4, 0]`），它能最大程度减少写操作（只会交换那个 0 相关的）。

这道题是 **快慢指针** 的经典应用，类似于“移除元素”或“数组去重”类题目，核心思想都是**利用一个指针维护“有效数据”的边界**。
