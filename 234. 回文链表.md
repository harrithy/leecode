# 回文链表

## 题目描述

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。

如果是，返回 `true`；否则返回 `false`。

## 示例

### 示例 1

```txt
输入：head = [1,2,2,1]
输出：true
```

### 示例 2

```txt
输入：head = [1,2]
输出：false
```

## 提示

- 链表中节点数目在范围 `[1, 10^5]` 内
- `0 <= Node.val <= 9`

## 解题思路

### 方法一：转数组后双指针（好理解）

先遍历链表，把值存到数组里，然后用左右指针判断是否回文。

- 左指针 `left = 0`
- 右指针 `right = arr.length - 1`
- 若 `arr[left] !== arr[right]`，直接返回 `false`
- 全部比较通过则返回 `true`

优点：思路直观。  
缺点：需要 `O(n)` 额外空间。

### 方法二：快慢指针 + 反转后半段（推荐）

目标是把额外空间优化到 `O(1)`。

步骤：

1. 用快慢指针找到链表中点  
   - `fast` 每次走两步，`slow` 每次走一步  
2. 从 `slow` 开始反转后半段链表  
3. 用两个指针分别从链表头和“后半段新头”出发比较值  
4. 只要有一处不等，返回 `false`；否则返回 `true`

> 说明：有些面试会要求“判断后还原链表”，可在比较后再反转一次后半段恢复原结构。

## 代码实现（JavaScript）

### 方法一：数组 + 双指针

```javascript
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
  const values = [];
  let curr = head;

  while (curr !== null) {
    values.push(curr.val);
    curr = curr.next;
  }

  let left = 0;
  let right = values.length - 1;

  while (left < right) {
    if (values[left] !== values[right]) return false;
    left++;
    right--;
  }

  return true;
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 方法二：快慢指针 + 反转后半段

```javascript
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
  if (head === null || head.next === null) return true;

  // 1) 找中点（偶数长度时 slow 落在右半部分起点）
  let slow = head;
  let fast = head;
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }

  // 2) 反转后半段
  let prev = null;
  let curr = slow;
  while (curr !== null) {
    const next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }

  // 3) 从头和后半段头同时比较
  let p1 = head;
  let p2 = prev; // 反转后半段的新头

  while (p2 !== null) {
    if (p1.val !== p2.val) return false;
    p1 = p1.next;
    p2 = p2.next;
  }

  return true;
};

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

## 方法二举例（`1 -> 2 -> 2 -> 1`）

1. 快慢指针找中点，`slow` 最终到第三个节点（值 `2`）  
2. 从 `slow` 开始反转：`2 -> 1` 变成 `1 -> 2`  
3. 比较：
   - 前半从头开始：`1 -> 2 -> ...`
   - 后半从反转头开始：`1 -> 2`
4. 两两相等，返回 `true`

## 常见易错点

- 快慢指针循环条件写错，导致空指针。
- 比较时应该以后半段指针 `p2` 为结束条件。
- 反转时忘记先保存 `next`，会丢链。
- 把“节点相等”写成比较引用，实际这里只需比较 `val`。

## 总结

- 想快速写对：用“数组 + 双指针”。
- 想达到进阶要求：用“快慢指针 + 反转后半段”，空间 `O(1)`。
- 本题和 `206. 反转链表` 强相关，后半段反转是核心操作。
