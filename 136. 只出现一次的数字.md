# 只出现一次的数字

## 题目描述

给你一个非空整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法，且只使用常量额外空间来解决此问题。

## 示例

### 示例 1

```txt
输入：nums = [2,2,1]
输出：1
```

### 示例 2

```txt
输入：nums = [4,1,2,1,2]
输出：4
```

### 示例 3

```txt
输入：nums = [1]
输出：1
```

## 提示

- `1 <= nums.length <= 3 * 10^4`
- `-3 * 10^4 <= nums[i] <= 3 * 10^4`
- 除了某个元素只出现一次以外，其余每个元素均出现两次

## 解题思路

### 方法一：异或运算（推荐，满足进阶要求）

核心性质：

- `a ^ a = 0`（相同数字异或为 0）
- `a ^ 0 = a`
- 异或满足交换律和结合律

所以把数组所有元素依次异或：

- 成对出现的数字会两两抵消为 `0`
- 最后剩下的就是只出现一次的数字

这也是本题最优解：时间 `O(n)`，空间 `O(1)`。

### 方法二：哈希表计数（好理解）

用 `Map` 统计每个数字出现次数，再找次数为 `1` 的数字即可。

优点：直观。  
缺点：空间复杂度 `O(n)`，不满足进阶“常量空间”要求。

## 代码实现（JavaScript）

### 方法一：异或运算

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
  let ans = 0;

  for (const num of nums) {
    ans ^= num;
  }

  return ans;
};

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 方法二：哈希表计数

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
  const map = new Map();

  for (const num of nums) {
    map.set(num, (map.get(num) || 0) + 1);
  }

  for (const [key, count] of map) {
    if (count === 1) return key;
  }

  return -1;
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

## 异或法举例

以 `nums = [4,1,2,1,2]` 为例：

```txt
初始 ans = 0
ans ^ 4 = 4
ans ^ 1 = 5
ans ^ 2 = 7
ans ^ 1 = 6   （1 被抵消）
ans ^ 2 = 4   （2 被抵消）
```

最终结果是 `4`。

## 常见易错点

- 把异或 `^` 写成乘方（JavaScript 里 `^` 是按位异或，不是幂运算）。
- 误用加减法去“抵消”重复数字，会在负数或复杂场景下出错。
- 哈希表法里忘记处理默认值，导致 `undefined + 1` 问题。

## 总结

- 本题最核心技巧是**异或消重**。
- 只要是“一个出现一次，其他出现两次”，基本都可以优先想到异或。
- 面试中优先写异或法，再补充哈希表法作为对照思路即可。
