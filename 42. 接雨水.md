# 接雨水

## 题目描述

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

## 示例

```txt
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
详情去力扣看图
```

```txt
输入：height = [4,2,0,3,2,5]
输出：9
```

## 提示

- n == height.length
- 1 <= n <= 2 \* 10^4
- 0 <= height[i] <= 10^5

## 思路

### 核心思想

对于每个位置 `i`，它能接的雨水量取决于：**左边最高柱子** 和 **右边最高柱子** 中较矮的那个，减去当前柱子高度。

```txt
水量[i] = min(左边最高, 右边最高) - height[i]
```

### 方法一：动态规划（预处理）

- 预先计算每个位置左边的最大高度数组 `leftMax[]`
- 预先计算每个位置右边的最大高度数组 `rightMax[]`
- 遍历每个位置计算水量

### 方法二：双指针（最优解）

- 使用双指针 `left` 和 `right` 从两端向中间移动
- 维护 `leftMax` 和 `rightMax` 分别表示左右两侧遇到的最大高度
- **关键洞察**：哪边的最大高度更小，就处理哪边
  - 如果 `leftMax < rightMax`，当前位置的水量由 `leftMax` 决定（因为右边一定有更高的柱子挡住）
  - 反之亦然

## 算法步骤（双指针）

1. **初始化**：`left = 0`，`right = n - 1`，`leftMax = 0`，`rightMax = 0`，`result = 0`
2. **循环** 当 `left < right` 时：
   - 如果 `height[left] < height[right]`：
     - 若 `height[left] >= leftMax`，更新 `leftMax = height[left]`
     - 否则，累加水量 `result += leftMax - height[left]`
     - 左指针右移 `left++`
   - 否则：
     - 若 `height[right] >= rightMax`，更新 `rightMax = height[right]`
     - 否则，累加水量 `result += rightMax - height[right]`
     - 右指针左移 `right--`
3. 返回 `result`

## 复杂度分析

| 方法     | 时间复杂度 | 空间复杂度 |
| -------- | ---------- | ---------- |
| 动态规划 | \(O(n)\)   | \(O(n)\)   |
| 双指针   | \(O(n)\)   | \(O(1)\)   |

## 代码实现（JavaScript）

### 方法一：动态规划

```js
var trap = function (height) {
  const n = height.length;
  if (n === 0) return 0;

  // 预处理左边最大高度
  const leftMax = new Array(n);
  leftMax[0] = height[0];
  for (let i = 1; i < n; i++) {
    leftMax[i] = Math.max(leftMax[i - 1], height[i]);
  }

  // 预处理右边最大高度
  const rightMax = new Array(n);
  rightMax[n - 1] = height[n - 1];
  for (let i = n - 2; i >= 0; i--) {
    rightMax[i] = Math.max(rightMax[i + 1], height[i]);
  }

  // 计算每个位置的水量
  let result = 0;
  for (let i = 0; i < n; i++) {
    result += Math.min(leftMax[i], rightMax[i]) - height[i];
  }

  return result;
};
```

### 方法二：双指针（推荐）

```js
var trap = function (height) {
    // 指针
    let left = 0;
    let right = height.length - 1;
    // 因为每一根竖线柱子能储存水的容量都等于当前最大值➖当前柱子的高度
    let leftMax = 0;
    let rightMax = 0;
    // 总值
    let result = 0;
    // 分左右两边处理
    while(left < right) {
        // 分左右两边处理,即比较最左边与最右边的柱子的高度，哪边低先处理哪边
        if(height[left] < height[right]) {
            // 如果当前的柱子大于该边的最大值，更新柱子最高的高度
            if(height[left] >= leftMax) {
                leftMax = height[left];
            }else {
                // 如果小于最大值的柱子高度，则说明可以装水，result = 对应最高高度 - 当前柱子高度
                result += leftMax - height[left];
            }
           left++;
        }else {
            // 右边同理
            if(height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                result += rightMax - height[right];
            }
            right--;
        }
        
    }
    return result;
};
```

## 总结

接雨水是经典的双指针题目，关键点：

1. **理解水量公式**：每个位置的水量 = min(左最高, 右最高) - 当前高度
2. **双指针优化**：哪边最大值更小就处理哪边，因为水量由较矮的一边决定
3. **空间优化**：从 O(n) 的预处理数组优化到 O(1) 的双指针
