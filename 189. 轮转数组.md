# 轮转数组

## 题目描述

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

## 示例

### 示例 1

```txt
输入：nums = [1,2,3,4,5,6,7], k = 3
输出：[5,6,7,1,2,3,4]
解释：
向右轮转 1 步：[7,1,2,3,4,5,6]
向右轮转 2 步：[6,7,1,2,3,4,5]
向右轮转 3 步：[5,6,7,1,2,3,4]
```

### 示例 2

```txt
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释：
向右轮转 1 步：[99,-1,-100,3]
向右轮转 2 步：[3,99,-1,-100]
```

## 提示

- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^5`

**进阶**：尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。你可以使用空间复杂度为 `O(1)` 的原地算法解决这个问题吗？

## 思路

### 方法一：使用额外数组（简单直接）

创建一个新数组，把每个元素放到轮转后的位置 `(i + k) % n`。

### 方法二：三次翻转（最优解）

这是一个非常巧妙的方法喵！不需要额外空间~

**核心观察**：向右轮转 k 位，相当于把数组的后 k 个元素移到前面。

**翻转三次的魔法**：

1. 先翻转整个数组
2. 再翻转前 k 个元素
3. 最后翻转后 n-k 个元素

**举个例子**：`nums = [1,2,3,4,5,6,7]`，`k = 3`

```txt
原数组：        [1, 2, 3, 4, 5, 6, 7]
翻转整个数组：   [7, 6, 5, 4, 3, 2, 1]
翻转前 k=3 个：  [5, 6, 7, 4, 3, 2, 1]
翻转后 n-k=4 个：[5, 6, 7, 1, 2, 3, 4]  ✓
```

是不是很神奇喵~ QAQ

### 方法三：环状替换

每个元素直接放到最终位置，被替换的元素继续往下放，形成一个环。这个方法比较复杂，面试一般用方法二就够啦~

## 复杂度分析

| 方法     | 时间复杂度 | 空间复杂度 |
| -------- | ---------- | ---------- |
| 额外数组 | $O(n)$     | $O(n)$     |
| 三次翻转 | $O(n)$     | $O(1)$     |
| 环状替换 | $O(n)$     | $O(1)$     |

## 代码实现（JavaScript）

### 方法一：使用额外数组

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function (nums, k) {
  const n = nums.length;
  // 创建新数组存放结果
  const result = new Array(n);

  for (let i = 0; i < n; i++) {
    // 计算轮转后的位置
    result[(i + k) % n] = nums[i];
  }

  // 把结果复制回原数组
  for (let i = 0; i < n; i++) {
    nums[i] = result[i];
  }
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 方法二：三次翻转（推荐）

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void}
 */
var rotate = function (nums, k) {
  const n = nums.length;
  // 注意：k 可能大于 n，需要取模
  k = k % n;

  // 翻转整个数组
  reverse(nums, 0, n - 1);
  // 翻转前 k 个元素
  reverse(nums, 0, k - 1);
  // 翻转后 n-k 个元素
  reverse(nums, k, n - 1);
};

/**
 * 翻转数组的 [start, end] 区间
 */
function reverse(nums, start, end) {
  while (start < end) {
    // 交换两端元素
    // 解构赋值写法
    // 假设 nums = [1, 2, 3, 4, 5]，start = 0，end = 4
    // 第一步：右边先计算，创建临时数组
    // [nums[4], nums[0]]  →  [5, 1]
    // 第二步：解构赋值给左边
    // nums[0] = 5
    // nums[1] = 1
    [nums[start], nums[end]] = [nums[end], nums[start]];
    start++;
    end--;
  }
}

// 时间复杂度：O(n)，每个元素被翻转两次
// 空间复杂度：O(1)，原地操作
```

## 流程演示

以 `nums = [1,2,3,4,5,6,7]`，`k = 3` 为例：

| 步骤 | 操作                   | 数组状态                |
| ---- | ---------------------- | ----------------------- |
| 初始 | -                      | `[1, 2, 3, 4, 5, 6, 7]` |
| 1    | 翻转整个数组 `[0, 6]`  | `[7, 6, 5, 4, 3, 2, 1]` |
| 2    | 翻转前 k=3 个 `[0, 2]` | `[5, 6, 7, 4, 3, 2, 1]` |
| 3    | 翻转后 4 个 `[3, 6]`   | `[5, 6, 7, 1, 2, 3, 4]` |

## 总结

轮转数组的关键点：

1. **取模处理**：`k = k % n`，因为轮转 n 次等于没转，k 可能比 n 大
2. **三次翻转**：这个技巧很经典，本质是利用翻转来"移动"元素，空间 $O(1)$
3. **原地修改**：题目要求修改原数组，不能直接 `return` 新数组

**为什么三次翻转有效？**

可以这样理解喵：

- 翻转整个数组 → 把后 k 个元素"甩"到前面，但顺序是反的
- 翻转前 k 个 → 把前 k 个的顺序调正
- 翻转后 n-k 个 → 把后 n-k 个的顺序调正

三次翻转，每个元素恰好被翻转两次，最终到达正确位置 QAQ
