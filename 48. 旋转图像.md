# 旋转图像

## 题目描述

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 **90 度**。

你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

## 示例

### 示例 1

```txt
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

```txt
旋转前：       旋转后：
1  2  3       7  4  1
4  5  6  →    8  5  2
7  8  9       9  6  3
```

### 示例 2

```txt
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

## 提示

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`

## 思路

### 方法一：先转置，再水平翻转（推荐）

这是最巧妙的方法喵！顺时针旋转 90° 可以分解为两步：

1. **转置**：沿主对角线翻转（行变列，列变行）
2. **水平翻转**：每一行左右翻转

```txt
原矩阵：        转置后：        水平翻转后：
1  2  3        1  4  7        7  4  1
4  5  6   →    2  5  8   →    8  5  2
7  8  9        3  6  9        9  6  3
```

### 方法二：四点轮换

直接把四个对应位置的元素轮换，一圈一圈从外向内处理。这个方法比较难写，容易出错。

### 为什么「转置 + 水平翻转 = 顺时针 90°」？

可以追踪一个点的位置变化喵~

对于位置 `(i, j)` 的元素：
- 转置后：`(i, j)` → `(j, i)`
- 水平翻转后：`(j, i)` → `(j, n-1-i)`

而顺时针旋转 90° 的公式正好是：`(i, j)` → `(j, n-1-i)` ✓

## 复杂度分析

- **时间复杂度**：$O(n^2)$，遍历矩阵两次
- **空间复杂度**：$O(1)$，原地操作

## 代码实现（JavaScript）

### 方法一：转置 + 水平翻转（推荐）

```javascript
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    const n = matrix.length;
    
    // 第一步：转置（沿主对角线翻转）
    for (let i = 0; i < n; i++) {
        // 注意 j 从 i+1 开始，只遍历上三角
        for (let j = i + 1; j < n; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
    
    // 第二步：水平翻转（每行左右翻转）
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < Math.floor(n / 2); j++) {
            [matrix[i][j], matrix[i][n - 1 - j]] = [matrix[i][n - 1 - j], matrix[i][j]];
        }
    }
};

// 时间复杂度：O(n²)
// 空间复杂度：O(1)
```

### 方法二：四点轮换

```javascript
/**
 * @param {number[][]} matrix
 * @return {void}
 */
var rotate = function(matrix) {
    const n = matrix.length;
    
    // 一圈一圈处理，从外到内
    for (let i = 0; i < Math.floor(n / 2); i++) {
        for (let j = i; j < n - 1 - i; j++) {
            // 保存左上角
            const temp = matrix[i][j];
            // 左上 ← 左下
            matrix[i][j] = matrix[n - 1 - j][i];
            // 左下 ← 右下
            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
            // 右下 ← 右上
            matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
            // 右上 ← 左上（temp）
            matrix[j][n - 1 - i] = temp;
        }
    }
};

// 时间复杂度：O(n²)
// 空间复杂度：O(1)
```

## 流程演示

以 `matrix = [[1,2,3],[4,5,6],[7,8,9]]` 为例（方法一）：

**第一步：转置**

交换 `(i, j)` 和 `(j, i)`，只处理上三角：

| 交换 | 操作 |
|------|------|
| (0,1) ↔ (1,0) | 2 ↔ 4 |
| (0,2) ↔ (2,0) | 3 ↔ 7 |
| (1,2) ↔ (2,1) | 6 ↔ 8 |

```txt
1  2  3      1  4  7
4  5  6  →   2  5  8
7  8  9      3  6  9
```

**第二步：水平翻转**

每行左右翻转：

```txt
1  4  7      7  4  1
2  5  8  →   8  5  2
3  6  9      9  6  3
```

**最终结果**：`[[7,4,1],[8,5,2],[9,6,3]]` ✓

## 知识点

### 矩阵旋转公式总结

| 旋转方向 | 操作 |
|----------|------|
| 顺时针 90° | 转置 + 水平翻转 |
| 逆时针 90° | 转置 + 垂直翻转 |
| 180° | 水平翻转 + 垂直翻转 |

### 转置 vs 翻转

| 操作 | 说明 | 公式 |
|------|------|------|
| 转置 | 沿主对角线翻转 | `(i, j)` → `(j, i)` |
| 水平翻转 | 每行左右翻转 | `(i, j)` → `(i, n-1-j)` |
| 垂直翻转 | 上下翻转 | `(i, j)` → `(n-1-i, j)` |

## 总结

旋转图像的关键点：

1. **分解操作**：顺时针 90° = 转置 + 水平翻转，比直接四点轮换简单多了
2. **转置技巧**：只遍历上三角（`j` 从 `i+1` 开始），避免交换两次
3. **原地操作**：用解构赋值交换，不需要额外空间

这道题和 189 题（轮转数组）思路类似，都是用**多次翻转**来实现复杂的位置变换喵 QAQ
