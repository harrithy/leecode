# 和为 K 的子数组

## 题目描述

给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回该数组中和为 `k` 的**子数组**的个数。

子数组是数组中元素的连续非空序列。

## 示例

### 示例 1

```txt
输入：nums = [1,1,1], k = 2
输出：2
```

### 示例 2

```txt
输入：nums = [1,2,3], k = 3
输出：2
```

## 提示

- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`

## 思路

### 核心想法：前缀和 + 哈希表

1. **前缀和定义**：设 `prefixSum[i]` 表示 `nums[0]` 到 `nums[i-1]` 的元素之和。那么子数组 `nums[i..j]` 的和就等于 `prefixSum[j+1] - prefixSum[i]`。

2. **转化问题**：我们要找的是满足 `prefixSum[j+1] - prefixSum[i] = k` 的 `(i, j)` 对数，即找 `prefixSum[i] = prefixSum[j+1] - k`。

3. **哈希表优化**：遍历数组时，用哈希表记录每个前缀和出现的次数。对于当前前缀和 `sum`，查找哈希表中 `sum - k` 出现的次数，累加到结果中。

4. **关键点**：初始化时需要 `map.set(0, 1)`，表示前缀和为 0 出现了 1 次（空前缀），用于处理从索引 0 开始的子数组。

## 算法步骤

1. 初始化哈希表 `map`，设置 `map.set(0, 1)`
2. 初始化 `count = 0`（结果计数）和 `sum = 0`（当前前缀和）
3. 遍历数组 `nums`：
   - 更新前缀和：`sum += nums[i]`
   - 如果 `map` 中存在 `sum - k`，将其出现次数累加到 `count`
   - 将当前 `sum` 的出现次数加 1 存入 `map`
4. 返回 `count`

## 复杂度分析

- **时间复杂度**：$O(n)$，只需遍历数组一次
- **空间复杂度**：$O(n)$，哈希表最多存储 n 个不同的前缀和

## 代码实现（JavaScript）

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {
  // 哈希表存储前缀和出现的次数
  const map = new Map();
  // 初始化：前缀和为 0 出现 1 次
  map.set(0, 1);

  let count = 0;
  let sum = 0;

  for (let i = 0; i < nums.length; i++) {
    // 计算当前前缀和
    sum += nums[i];

    // 如果存在 sum - k，说明存在和为 k 的子数组
    if (map.has(sum - k)) {
      count += map.get(sum - k);
    }

    // 更新当前前缀和的出现次数
    map.set(sum, (map.get(sum) || 0) + 1);
  }

  return count;
};
```

## 总结

1. **前缀和技巧**：将子数组求和问题转化为两个前缀和的差值问题。
2. **哈希表加速**：通过哈希表在 $O(1)$ 时间内查找是否存在满足条件的前缀和。
3. **初始化陷阱**：不要忘记 `map.set(0, 1)`，否则会漏掉从数组开头开始的子数组。
4. **与滑动窗口的区别**：由于数组元素可以为负数，无法使用滑动窗口（窗口无单调性），必须使用前缀和 + 哈希表。
