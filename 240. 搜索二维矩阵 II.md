# 240. 搜索二维矩阵 II

## 题目描述

给你一个满足下列两条性质的 `m x n` 整数矩阵 `matrix`：

- 每行元素从左到右升序排列；
- 每列元素从上到下升序排列。

再给你一个整数 `target`，请判断 `target` 是否在矩阵中出现。

返回 `true` 或 `false`。

## 示例

### 示例 1

```txt
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

### 示例 2

```txt
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

## 提示

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-10^9 <= matrix[i][j] <= 10^9`
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- `-10^9 <= target <= 10^9`

## 思路

### 方法一：从右上角开始“排除法”（最优）

我们从右上角 `(row = 0, col = n - 1)` 出发。

为什么选右上角？因为这个位置同时具备：

- 往左变小；
- 往下变大。

所以每一步都能排除一整行或一整列：

- 若 `matrix[row][col] === target`，直接返回 `true`；
- 若 `matrix[row][col] > target`，说明当前列这一格以及其下方都更大，目标不可能在这一列右侧（已经没有右侧），因此 `col--`（左移）；
- 若 `matrix[row][col] < target`，说明当前行这一格以及其左侧都更小，目标不可能在这一行，因此 `row++`（下移）。

当 `row` 越界或 `col` 越界时还没找到，返回 `false`。

### 方法二：逐行二分（可做备选）

对每一行做一次二分查找，时间复杂度是 `O(m log n)`。

这个方法也能过，但不如方法一的 `O(m + n)` 高效。

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 |
| --- | --- | --- |
| 右上角排除法 | `O(m + n)` | `O(1)` |
| 逐行二分 | `O(m log n)` | `O(1)` |

## 代码实现（JavaScript）

### 方法一：右上角排除法（推荐）

```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function (matrix, target) {
  const m = matrix.length;
  const n = matrix[0].length;

  let row = 0;
  let col = n - 1;

  while (row < m && col >= 0) {
    const cur = matrix[row][col];

    if (cur === target) {
      return true;
    }

    if (cur > target) {
      col--;
    } else {
      row++;
    }
  }

  return false;
};
```

### 方法二：逐行二分

```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function (matrix, target) {
  const m = matrix.length;
  const n = matrix[0].length;

  const binarySearch = (arr, target) => {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
      const mid = left + ((right - left) >> 1);

      if (arr[mid] === target) {
        return true;
      }

      if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    return false;
  };

  for (let i = 0; i < m; i++) {
    if (target < matrix[i][0] || target > matrix[i][n - 1]) {
      continue;
    }

    if (binarySearch(matrix[i], target)) {
      return true;
    }
  }

  return false;
};
```

## 小结

这题的核心是利用“行、列都升序”的双重有序性：

- 右上角（或左下角）是天然的决策点；
- 每一步都能排除一整行或一整列；
- 因此能做到线性复杂度 `O(m + n)`。

同类型题目里，只要遇到“二维单调矩阵 + 查找值”，都可以优先考虑这种“拐角出发 + 单步排除”的写法。
