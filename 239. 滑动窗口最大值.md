# 滑动窗口最大值

## 题目描述

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 _滑动窗口中的最大值_ 。

## 示例

```txt
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

```txt
输入：nums = [1], k = 1
输出：[1]
```

## 提示

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`

## 思路

### 核心想法：单调队列

这是一个经典的滑动窗口问题。我们需要在窗口移动的过程中，快速找到窗口内的最大值。

如果使用暴力法，每次遍历窗口找最大值，时间复杂度是 $O(n \times k)$，会超时。
我们可以使用 **单调队列** 来优化，将寻找最大值的时间复杂度降低到 $O(1)$。

**单调队列** 的特点：

1. 队列中的元素（通常存储下标）对应的数值是 **单调递减** 的。
2. **队首** 元素始终是当前窗口内的 **最大值**。

### 算法步骤

遍历数组 `nums`，对于每个元素 `nums[i]`：

1. **入队前清理**：如果队列不为空，且当前元素 `nums[i]` 大于等于队尾元素，说明队尾元素不可能是窗口内的最大值了（因为 `nums[i]` 更大且出现更晚），将其弹出。重复此过程直到保持单调递减。
2. **入队**：将当前元素下标 `i` 加入队尾。
3. **出队（维护窗口大小）**：检查队首下标是否已经滑出窗口（即 `q[0] <= i - k`），如果是，则将队首移除。
4. **记录结果**：当窗口形成（`i >= k - 1`）时，队首元素 `nums[q[0]]` 即为当前窗口最大值，加入结果数组。

## 复杂度分析

- **时间复杂度**：$O(n)$。虽然有 while 循环，但每个元素最多进队一次、出队一次，所以均摊复杂度是线性的。
- **空间复杂度**：$O(k)$。双端队列最多存储 $k$ 个元素的下标。

## 代码实现（JavaScript）

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {
  const q = [] // 双端队列，存储下标
  const ans = []

  for (let i = 0; i < nums.length; i++) {
    // 1. 维护队列单调递减：如果当前元素比队尾大，队尾就没有存在的意义了
    while (q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop()
    }

    // 2. 入队：存储下标
    q.push(i)

    // 3. 维护窗口范围：如果队首下标已滑出窗口，移除它
    // 当前窗口范围是 [i - k + 1, i]
    if (q[0] <= i - k) {
      q.shift()
    }

    // 4. 记录结果：当窗口长度达到 k 时开始记录
    if (i >= k - 1) {
      ans.push(nums[q[0]])
    }
  }

  return ans
}
```

## 总结

1. **单调队列** 是解决滑动窗口最值问题的利器。
2. 队列存储 **下标** 而不是数值，是为了方便判断元素是否滑出窗口。
3. 保持队列 **单调递减**，队首即为最大值。
