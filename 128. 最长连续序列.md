# 128. 最长连续序列

## 题目描述

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

## 示例

**示例 1：**

```txt
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```txt
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

## 提示

- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

## 解决方案

### 方法一：哈希表 (Set)

题目要求时间复杂度为 `O(n)`，这意味着我们不能使用 `O(n log n)` 的排序算法。我们可以利用哈希表（`Set`）来实现 `O(1)` 的查找，从而达到线性时间复杂度。

**思路：**

1. **去重与快速查找**：首先将数组中的所有元素放入一个 `Set` 中，去除重复元素，并允许我们在 `O(1)` 时间内判断一个数是否存在。
2. **寻找起点**：遍历 `Set` 中的每一个元素 `num`。
    - 如果 `num - 1` 存在于 `Set` 中，说明 `num` 肯定不是一个连续序列的**起点**（因为 `num-1` 在它前面），我们可以跳过它，避免重复计算。
    - 如果 `num - 1` 不存在，说明 `num` 是一个连续序列的起点。
3. **计算长度**：从起点 `num` 开始，不断尝试匹配 `num + 1`、`num + 2`... 是否存在于 `Set` 中，直到中断。统计当前序列的长度。
4. **更新最大值**：每次找到一个连续序列，都与当前记录的最大长度进行比较，保留较大值。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    // 创建一个 Set 来存储数组中的元素，以便快速查找
    const numSet = new Set(nums);
    // 初始化最长连续序列长度为 0
    let longestStreak = 0;
    // 遍历 Set 中的每一个元素 num
    for (const num of numSet) {
        // 如果 num - 1 存在于 Set 中，说明 num 肯定不是一个连续序列的起点，跳过它
        if (!numSet.has(num - 1)) {
            // 从 num 开始，不断尝试匹配 num + 1, num + 2, ... 是否存在于 Set 中
            let currentNum = num;
            // 初始化当前连续序列长度为 1
            let currentStreak = 1;
            // 不断尝试匹配 num + 1, num + 2, ... 是否存在于 Set 中
            while (numSet.has(currentNum + 1)) {
                // 如果当前数加 1 仍然存在于 Set 中，说明可以继续向后匹配
                currentNum += 1;
                // 当前连续序列长度加 1
                currentStreak += 1;
            }
            // 当currentNum不存在于Set中时，结束内层循环
            // 更新最长连续序列长度
            longestStreak = Math.max(longestStreak, currentStreak);
        }
    }

    return longestStreak;
};

// 时间复杂度：O(n)。
// 虽然看起来有双重循环，但外层循环需要 O(n) 的时间。
// 只有当一个数是连续序列的第一个数的情况下，才会进入内层 while 循环。
// 换句话说，数组中的每个数最多会被访问两次（一次是在外层循环中，一次是在内层循环中）。
// 因此总时间复杂度为 O(n)。

// 空间复杂度：O(n)。需要使用哈希表存储数组中的元素。
```

## 总结

![image.png](https://image.harrio.xyz/file/AgACAgUAAyEGAAS0fTaFAANLaWnbvFZmwZLucXL0AAHb06jmUWs3AAJADmsbWjVRV0CnulNCJWwpAQADAgADeQADOAQ.png)

- 通过使用 `Set`，我们实现了 `O(1)` 的查找时间复杂度，从而满足了题目要求的线性时间复杂度。
- 代码中通过判断 `num - 1` 是否存在于 `Set` 中，巧妙地找到了每个连续序列的起点，避免了重复计算。
- 最终，我们返回了最长连续序列的长度。
