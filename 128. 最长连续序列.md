# 128. 最长连续序列

## 题目描述

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

## 示例

**示例 1：**

```txt
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```txt
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

## 提示

- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

## 解决方案

### 方法一：哈希表 (Set)

题目要求时间复杂度为 `O(n)`，这意味着我们不能使用 `O(n log n)` 的排序算法。我们可以利用哈希表（`Set`）来实现 `O(1)` 的查找，从而达到线性时间复杂度。

**思路：**

1. **去重与快速查找**：首先将数组中的所有元素放入一个 `Set` 中，去除重复元素，并允许我们在 `O(1)` 时间内判断一个数是否存在。
2. **寻找起点**：遍历 `Set` 中的每一个元素 `num`。
    - 如果 `num - 1` 存在于 `Set` 中，说明 `num` 肯定不是一个连续序列的**起点**（因为 `num-1` 在它前面），我们可以跳过它，避免重复计算。
    - 如果 `num - 1` 不存在，说明 `num` 是一个连续序列的起点。
3. **计算长度**：从起点 `num` 开始，不断尝试匹配 `num + 1`、`num + 2`... 是否存在于 `Set` 中，直到中断。统计当前序列的长度。
4. **更新最大值**：每次找到一个连续序列，都与当前记录的最大长度进行比较，保留较大值。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    // 1. 使用 Set 去重并支持 O(1) 查找
    const numSet = new Set(nums);
    let longestStreak = 0;

    for (const num of numSet) {
        // 2. 只有当 num 是序列的起点时（即 num - 1 不在 Set 中），才开始向后寻找
        if (!numSet.has(num - 1)) {
            let currentNum = num;
            let currentStreak = 1;

            // 3. 不断寻找 num + 1, num + 2 ...
            while (numSet.has(currentNum + 1)) {
                currentNum += 1;
                currentStreak += 1;
            }

            // 4. 更新最大长度
            longestStreak = Math.max(longestStreak, currentStreak);
        }
    }

    return longestStreak;
};

// 时间复杂度：O(n)。
// 虽然看起来有双重循环，但外层循环需要 O(n) 的时间。
// 只有当一个数是连续序列的第一个数的情况下，才会进入内层 while 循环。
// 换句话说，数组中的每个数最多会被访问两次（一次是在外层循环中，一次是在内层循环中）。
// 因此总时间复杂度为 O(n)。

// 空间复杂度：O(n)。需要使用哈希表存储数组中的元素。
```

## 总结

这道题的关键在于如何利用 **哈希表** 将时间复杂度优化到 `O(n)`。

如果直接对每个数都尝试向后寻找（即不判断 `!numSet.has(num - 1)`），最坏情况下（例如 `[1, 2, 3, ..., n]`）时间复杂度会退化到 `O(n^2)`。

通过判断 **“是否为序列起点”** 这一剪枝逻辑，我们保证了每个连续序列只会被完整扫描一次，从而严格保证了线性的时间复杂度。
