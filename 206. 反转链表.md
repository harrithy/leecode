# 反转链表

## 题目描述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

## 示例

### 示例 1

```txt
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

### 示例 2

```txt
输入：head = [1,2]
输出：[2,1]
```

### 示例 3

```txt
输入：head = []
输出：[]
```

## 提示

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

## 解题思路

### 方法一：迭代法（推荐）

核心思路：用三个指针逐个反转链表方向。

- `prev`：当前节点的前一个节点（初始为 `null`）
- `curr`：当前正在处理的节点（初始为 `head`）
- `next`：暂存 `curr.next`，防止断链

每一步做三件事：

1. 先保存下一个节点：`next = curr.next`
2. 反转指针方向：`curr.next = prev`
3. 整体向前推进：`prev = curr`，`curr = next`

循环结束后，`prev` 就是新头节点。

### 方法二：递归法

递归到链表末尾后，开始回溯反转：

- 设 `newHead = reverseList(head.next)` 拿到反转后的新头
- 让 `head.next.next = head` 把后一个节点指回当前节点
- 再把 `head.next = null` 断开旧方向

最后返回 `newHead`。

## 代码实现（JavaScript）

### 方法一：迭代法

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  // 记录当前节点的前一个节点(初始值为null)
  let prev = null;
  // 记录当前处理的节点(初始值为head)
  let curr = head;
  // 一直循环到链表的最后
  while (curr !== null) {
    // 1. 保存下一个节点，避免断链
    const next = curr.next;
    // 2. 反转当前指针
    curr.next = prev;
    // 3. 双指针向前推进
    prev = curr;
    curr = next;
  }

  return prev;
};
var reverseList = function(head) {
    // 设置一个链表
    let pA = null;
    // 记录当前的地址
    let pB = head;
    // 开始反转
    while(pB != null) {
        // 保留下一个节点 pC = 2
        const pC = pB.next;
        // 改变pB的下一个指向  原本 1 -> 2 现在 1 -> null
        pB.next = pA;
        // 改变pA的地址值 原本是 null 现在是 1 同时指向null 也是 1 -> null
        pA = pB;
        // 改变pB的地址值 原本是 1 原本指向 1 -> 2 现在变为 2 现在的指向 2 -> 3
        pB = pC;
    }
    // 循环结束返回反转链表
    return pA;

};

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 方法二：递归法

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  // 空链表或只有一个节点，直接返回
  if (head === null || head.next === null) return head;

  // 递归反转 head 之后的链表
  const newHead = reverseList(head.next);

  // 回溯时反转指针
  head.next.next = head;
  head.next = null;

  return newHead;
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)（递归调用栈）
```

## 迭代法走一遍示例

以 `1 -> 2 -> 3 -> null` 为例：

- 初始：`prev = null`，`curr = 1`
- 第 1 轮后：`1 -> null`，`prev = 1`，`curr = 2`
- 第 2 轮后：`2 -> 1 -> null`，`prev = 2`，`curr = 3`
- 第 3 轮后：`3 -> 2 -> 1 -> null`，`prev = 3`，`curr = null`
- 循环结束，返回 `prev`（即节点 `3`）

## 常见易错点

- 忘记提前保存 `curr.next`，导致后续节点丢失。
- 循环结束后返回 `head` 而不是 `prev`。
- 递归法中忘记 `head.next = null`，会形成环。

## 总结

- 这道题是链表指针操作的基础题，建议优先掌握迭代写法。
- 迭代法空间最优（`O(1)`），面试中最常用。
- 递归法代码更短，但会使用额外栈空间。
