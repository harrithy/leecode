# 螺旋矩阵

## 题目描述

给你一个 `m` 行 `n` 列的矩阵 `matrix`，请按照**顺时针螺旋顺序**，返回矩阵中的所有元素。

## 示例

### 示例 1

```txt
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

```txt
→ → →
    ↓
← ← ↓
↑   ↓
↑ → →

遍历顺序：1→2→3→6→9→8→7→4→5
```

### 示例 2

```txt
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

## 提示

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

## 思路

### 核心想法：模拟 + 边界收缩

按照「右 → 下 → 左 → 上」的顺序遍历，每遍历完一条边，就把对应的边界收缩。

**定义四个边界**：
- `top`：上边界
- `bottom`：下边界
- `left`：左边界
- `right`：右边界

**遍历顺序**：
1. 从左到右遍历上边界，然后 `top++`（上边界下移）
2. 从上到下遍历右边界，然后 `right--`（右边界左移）
3. 从右到左遍历下边界，然后 `bottom--`（下边界上移）
4. 从下到上遍历左边界，然后 `left++`（左边界右移）

重复以上步骤，直到所有元素都被遍历。

## 复杂度分析

- **时间复杂度**：$O(m \times n)$，每个元素访问一次
- **空间复杂度**：$O(1)$，不算输出数组的话只用了常数空间

## 代码实现（JavaScript）

```javascript
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    const result = [];
    if (matrix.length === 0) return result;
    
    // 定义四个边界
    let top = 0;
    let bottom = matrix.length - 1;
    let left = 0;
    let right = matrix[0].length - 1;
    
    while (top <= bottom && left <= right) {
        // 1. 从左到右遍历上边界
        for (let j = left; j <= right; j++) {
            result.push(matrix[top][j]);
        }
        top++;  // 上边界下移
        
        // 2. 从上到下遍历右边界
        for (let i = top; i <= bottom; i++) {
            result.push(matrix[i][right]);
        }
        right--;  // 右边界左移
        
        // 3. 从右到左遍历下边界（注意要检查 top <= bottom）
        if (top <= bottom) {
            for (let j = right; j >= left; j--) {
                result.push(matrix[bottom][j]);
            }
            bottom--;  // 下边界上移
        }
        
        // 4. 从下到上遍历左边界（注意要检查 left <= right）
        if (left <= right) {
            for (let i = bottom; i >= top; i--) {
                result.push(matrix[i][left]);
            }
            left++;  // 左边界右移
        }
    }
    
    return result;
};

// 时间复杂度：O(m × n)
// 空间复杂度：O(1)
```

## 流程演示

以 `matrix = [[1,2,3],[4,5,6],[7,8,9]]` 为例：

**初始边界**：`top=0, bottom=2, left=0, right=2`

| 轮次 | 方向 | 遍历元素 | 边界变化 |
|------|------|----------|----------|
| 1 | → 上边界 | 1, 2, 3 | top: 0→1 |
| 1 | ↓ 右边界 | 6, 9 | right: 2→1 |
| 1 | ← 下边界 | 8, 7 | bottom: 2→1 |
| 1 | ↑ 左边界 | 4 | left: 0→1 |
| 2 | → 上边界 | 5 | top: 1→2 |

**边界变化图示**：

```txt
第一轮：
[1, 2, 3]  →→→     top=0
[4, 5, 6]      ↓   
[7, 8, 9]  ←←← ↓   bottom=2

第二轮（只剩中心）：
[5]  →  top=1, bottom=1, left=1, right=1
```

**最终结果**：`[1, 2, 3, 6, 9, 8, 7, 4, 5]` ✓

## 为什么要额外检查边界？

在第 3 步和第 4 步需要额外检查 `top <= bottom` 和 `left <= right`，这是为了处理**单行或单列**的情况喵~

```txt
例如：matrix = [[1, 2, 3]]（单行）

第一轮：
- → 遍历上边界：1, 2, 3，然后 top++（top=1）
- ↓ 遍历右边界：无（top > bottom）
- ← 遍历下边界：如果不检查，会重复遍历！

所以要检查 top <= bottom，避免重复。
```

## 总结

螺旋矩阵的关键点：

1. **边界收缩法**：用四个变量维护当前的边界，每遍历完一条边就收缩
2. **遍历顺序**：右 → 下 → 左 → 上，循环往复
3. **边界检查**：遍历下边界和左边界前要检查，避免单行/单列时重复遍历

**相关题目**：
- 59. 螺旋矩阵 II（反过来，生成螺旋矩阵）
- 885. 螺旋矩阵 III

这类题没有什么算法技巧，就是纯模拟，细心一点就好喵 QAQ
