# 多数元素

## 题目描述

给定一个大小为 n 的数组 `nums`，返回其中的多数元素。多数元素是指出现次数 **大于** `⌊n/2⌋` 的元素。

题目保证数组非空且一定存在多数元素。

## 示例

### 示例 1

```txt
输入：nums = [3,2,3]
输出：3
```

### 示例 2

```txt
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

## 提示

- `1 <= nums.length <= 5 * 10^4`
- `-10^9 <= nums[i] <= 10^9`
- 数组中总存在多数元素

## 解题思路

### 方法一：摩尔投票法（推荐）

核心思想：不同元素两两抵消，多数元素最终不会被完全抵消。

维护两个变量：

- `candidate`：当前候选元素
- `count`：候选元素的票数

遍历数组：

- 当 `count == 0` 时，更新 `candidate = nums[i]`
- 若 `nums[i] == candidate`，`count++`
- 否则 `count--`

由于多数元素出现次数 > n/2，最终 `candidate` 必然是答案。

### 方法二：哈希表计数（直观）

统计每个元素出现次数，返回次数超过 n/2 的元素。

### 方法三：排序取中位数

多数元素超过半数，排序后中间位置 `nums[n/2]` 必是多数元素。

## 代码实现（JavaScript）

### 方法一：摩尔投票法

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
  let candidate = null;
  let count = 0;

  for (const num of nums) {
    if (count === 0) {
      candidate = num;
    }
    count += num === candidate ? 1 : -1;
  }

  return candidate;
};

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 方法二：哈希表计数

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
  const map = new Map();
  const limit = Math.floor(nums.length / 2);

  for (const num of nums) {
    const count = (map.get(num) || 0) + 1;
    if (count > limit) return num;
    map.set(num, count);
  }

  return -1;
};

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 方法三：排序取中位数

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
  nums.sort((a, b) => a - b);
  return nums[Math.floor(nums.length / 2)];
};

// 时间复杂度：O(n log n)
// 空间复杂度：O(1)~O(log n)，取决于排序实现
```

## 常见易错点

- `count` 归零时忘记更新 `candidate`
- 题目保证存在多数元素，否则需要二次验证
- 排序法会改变原数组，需要时先拷贝

## 总结

- 多数元素题首选摩尔投票法，线性时间、常量空间。
- 哈希表法直观但占用额外空间。
- 排序法简单，但时间复杂度更高且会改变数组。
