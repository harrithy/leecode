# 缺失的第一个正数

## 题目描述

给你一个未排序的整数数组 `nums`，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

## 示例

### 示例 1

```txt
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

### 示例 2

```txt
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

### 示例 3

```txt
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正整数 1 没有出现。
```

## 提示

- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`

## 思路

### 方法一：排序法（我的做法）

先排序，然后从 1 开始找第一个缺失的正整数。

**思路**：排序后遍历数组，用变量 `zheng` 记录当前找到的最大连续正整数。如果下一个数刚好是 `zheng + 1`，就更新 `zheng`。

**缺点**：排序的时间复杂度是 $O(n \log n)$，不满足题目要求的 $O(n)$，但是能 AC 喵~

### 方法二：原地哈希（最优解）

这是一个很巧妙的方法！核心思想是**把数组本身当作哈希表**。

**关键洞察**：对于长度为 n 的数组，答案一定在 `[1, n+1]` 范围内。
- 如果数组包含 `1, 2, 3, ..., n`，答案就是 `n + 1`
- 否则答案一定是 `[1, n]` 中某个缺失的数

**做法**：把每个数 `x`（如果 `1 <= x <= n`）放到索引 `x - 1` 的位置上。
- 数字 1 放到索引 0
- 数字 2 放到索引 1
- ...
- 数字 n 放到索引 n-1

最后遍历数组，第一个 `nums[i] != i + 1` 的位置，`i + 1` 就是答案。

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| 排序法 | $O(n \log n)$ | $O(\log n)$ |
| 原地哈希 | $O(n)$ | $O(1)$ |

## 代码实现（JavaScript）

### 方法一：排序法（我的做法）

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
    nums.sort((a, b) => a - b);
    
    // 只有一个元素
    if (nums.length == 1) {
        if (nums[0] < 0) {
            return 1;
        }
        if (nums[0] == 0) {
            return 1;
        }
        if (nums[0] > 0 && nums[0] != 1) {
            return 1;
        }
        return 2;
    }
    
    if (nums[0] > 1) {
        return 1;
    }
    
    let zheng = 1;
    
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] < 0) {
            zheng = 1;
        }
        if ((zheng + 1) == nums[i]) {
            zheng = nums[i];
        }
    }
    
    if (nums[nums.length - 1] < 0) {
        return zheng;
    }
    
    if (!nums.includes(1)) {
        return 1;
    }
    
    return zheng + 1;
};

// 时间复杂度：O(n log n)，排序的开销
// 空间复杂度：O(log n)，排序的栈空间
```

### 方法二：原地哈希（最优解）

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
    const n = nums.length;
    
    // 把每个数放到正确的位置上
    // 数字 x 应该放在索引 x-1 的位置
    for (let i = 0; i < n; i++) {
        // 当 nums[i] 在 [1, n] 范围内，且不在正确位置时，交换
        while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {
            // 把 nums[i] 放到索引 nums[i]-1 的位置
            const targetIndex = nums[i] - 1;
            [nums[i], nums[targetIndex]] = [nums[targetIndex], nums[i]];
        }
    }
    
    // 找第一个不在正确位置的数
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) {
            return i + 1;
        }
    }
    
    // 如果 1~n 都在，答案就是 n+1
    return n + 1;
};

// 时间复杂度：O(n)，每个数最多被交换一次
// 空间复杂度：O(1)，原地操作
```

## 流程演示

以 `nums = [3, 4, -1, 1]` 为例（原地哈希法）：

**目标**：把数字 x 放到索引 x-1 的位置

| 步骤 | i | nums[i] | 操作 | 数组状态 |
|------|---|---------|------|----------|
| 初始 | - | - | - | `[3, 4, -1, 1]` |
| 1 | 0 | 3 | 3 应该在索引 2，交换 | `[-1, 4, 3, 1]` |
| 2 | 0 | -1 | 负数不处理 | `[-1, 4, 3, 1]` |
| 3 | 1 | 4 | 4 应该在索引 3，交换 | `[-1, 1, 3, 4]` |
| 4 | 1 | 1 | 1 应该在索引 0，交换 | `[1, -1, 3, 4]` |
| 5 | 1 | -1 | 负数不处理 | `[1, -1, 3, 4]` |
| 6 | 2 | 3 | 3 已在正确位置 | `[1, -1, 3, 4]` |
| 7 | 3 | 4 | 4 已在正确位置 | `[1, -1, 3, 4]` |

**检查**：
- `nums[0] = 1 = 0 + 1` ✓
- `nums[1] = -1 ≠ 1 + 1` ✗ → 返回 **2**

## 总结

这道题是 Hard 难度，关键点：

对于第一点的解释 比如有一个数组 n = 4 那他的范围就在1-5之间 
因为在最理想的情况下里面会存在 [1,2,3,4] 所以最小的就是5 如果不是理想情况那范围就在1-4 

1. **答案范围**：对于长度为 n 的数组，答案一定在 `[1, n+1]` 内
2. **原地哈希**：把数组本身当哈希表，数字 x 放到索引 x-1 的位置
3. **while 循环**：用 while 而不是 if，因为交换过来的数可能还需要继续交换

**排序法**虽然不满足 $O(n)$ 的要求，但思路直观，面试时如果想不到最优解，先写出来再优化也是可以的喵 QAQ
